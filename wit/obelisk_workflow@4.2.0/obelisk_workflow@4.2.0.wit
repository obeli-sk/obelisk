package obelisk:workflow@4.2.0;

@since(version = 4.0.0)
interface workflow-support {
    use obelisk:types/time@4.1.0.{schedule-at, datetime};
    use obelisk:types/execution@4.1.0.{delay-id, execution-id, response-id, function, submit-config};
    use obelisk:types/join-set@4.1.0.{join-set};

    /// Error variants that may occur on named join set creation.
    /// The name may only contain alphanumeric characters and the following extra characters:
    /// * dash `-`
    /// * forward slash `/`
    @since(version = 3.0.0)
    variant join-set-create-error {
        conflict,
        invalid-name(string),
    }

    @since(version = 4.1.0)
    variant get-result-json-error {
        execution-id-parsing-error(string),
        /// Processed responses do not contain the specified execution ID.
        /// Execution was not awaited using `-await-next` extension or `join-set.join-next`.
        not-found-in-processed-responses,
    }

    @since(version = 4.1.0)
    variant submit-json-error {
        /// See `Function` definition
        ffqn-parsing-error(string),
        function-not-found,
        params-parsing-error(string),
    }

    @since(version = 4.2.0)
    variant schedule-json-error {
        /// See `Function` definition
        ffqn-parsing-error(string),
        function-not-found,
        params-parsing-error(string),
    }

    /// Error variants that may occur when calling `join-next` function.
    @since(version = 4.1.0)
    variant join-next-error {
        /// All submitted requests and their responses were already processed.
        all-processed,
    }

    /// Error variants that may occur when calling `join-next-try` function.
    @since(version = 4.1.0)
    variant join-next-try-error {
        /// All submitted requests and their responses were already processed.
        all-processed,
        /// No response is available yet, but there are pending requests.
        pending,
    }

    /// Returns a random u64 in the range [min, max).
    @since(version = 3.0.0)
    random-u64: func(min: u64, max-exclusive: u64) -> u64;
    /// Returns a random u64 in the range [min, max].
    @since(version = 3.0.0)
    random-u64-inclusive: func(min: u64, max-inclusive: u64) -> u64;

    /// Returns a random string with a length in the range [min_length, max_length).
    /// The string consists only of alphanumeric characters (lowercase and uppercase letters, digits).
    @since(version = 3.0.0)
    random-string: func(min-length: u16, max-length-exclusive: u16) -> string;

    /// Block execution for given time, return the time when the durable sleep expires.
    /// Returns error if the delay is cancelled.
    @since(version = 4.0.0)
    sleep: func(schedule-at: schedule-at) -> result<datetime>;

    /// Create a new join set with a generated name.
    @since(version = 4.0.0)
    join-set-create: func() -> join-set;

    /// Create a new join set with the specified name.
    /// The name may only contain alphanumeric characters and the following extra characters:
    /// * dash `-`
    /// * forward slash `/`
    @since(version = 4.0.0)
    join-set-create-named: func(name: string) -> result<join-set, join-set-create-error>;

    /// Explicitly close join set. Unawaited delay requests are ignored,
    /// unawaited activities are cancelled, unawaited child workflows block
    /// until finish, as mandated by structured concurrency pattern.
    /// Extension function `-get` can be later used to lookup the execution result.
    @since(version = 4.0.0)
    join-set-close: func(self: join-set);

    /// Submit a child execution request with its parameters serialized as JSON array to a join set.
    @since(version = 4.1.0)
    submit-json: func(join-set: borrow<join-set>, function: function, params: string, config: option<submit-config>) -> result<execution-id, submit-json-error>;

    /// Obtain child execution result after it has been awaited using `-await-next` extension or `join-set.join-next`.
    @since(version = 4.1.0)
    get-result-json: func(execution-id: execution-id) -> result<result<option<string>, option<string>>, get-result-json-error>;

    /// Submit a delay request to the join set. The delay can be later polled using `join-next`.
    @since(version = 4.1.0)
    submit-delay: func(join-set: borrow<join-set>, timeout: schedule-at) -> delay-id;

    /// Schedule a child execution request with its parameters serialized as JSON array.
    @since(version = 4.2.0)
    schedule-json: func(schedule-at: schedule-at, function: function, params: string, config: option<submit-config>) -> result<execution-id, schedule-json-error>;

    /// Block the workflow execution until next response associated with the join set arrives.
    /// The response is marked as processed.
    /// Child execution result can be obtained using `-get` extension function using the
    /// returned execution ID.
    /// Return `join-next-error::all-processed` if the join set has all requests matched with responses already processed.
    @since(version = 4.1.0)
    join-next: func(join-set: borrow<join-set>) -> result<tuple<response-id, result>, join-next-error>;

    /// Error variants that may occur when calling `stub-json`.
    @since(version = 4.2.0)
    variant stub-json-error {
        /// Cannot parse the execution ID.
        execution-id-parsing-error(string),
        /// The target execution was not found or FFQN does not match.
        not-found,
        /// Cannot parse the result as JSON.
        result-parsing-error(string),
        /// Write conflict â€” a different result was already stubbed.
        conflict,
    }

    /// Write a stub response with a JSON-serialized result for an activity_stub or activity_external execution.
    /// The `execution-id` must be a derived (child) execution ID.
    /// The `result-json` is the JSON-serialized return value.
    @since(version = 4.2.0)
    stub-json: func(execution-id: execution-id, result-json: string) -> result<_, stub-json-error>;

    /// Attempt to process next response without blocking.
    /// Child execution result can be obtained using `-get` extension function using the
    /// returned execution ID.
    /// Return `join-next-try-error::all-processed` if the join set has all requests matched with responses already processed.
    /// Return `join-next-try-error::pending` if no response is available yet, but there are pending requests.
    @since(version = 4.1.0)
    join-next-try: func(join-set: borrow<join-set>) -> result<tuple<response-id, result>, join-next-try-error>;
}
