---
source: crates/utils/src/wit.rs
expression: wit
---
package root:component;

world root {
  import obelisk:types/time@4.1.0;
  import obelisk:types/execution@4.1.0;
  import obelisk:types/join-set@4.1.0;
  import obelisk:workflow/workflow-support@4.1.0;
  import testing:fibo/fibo;
  import testing:fibo-obelisk-ext/fibo;

  export testing:fibo-workflow/workflow;
  export testing:fibo-workflow-obelisk-ext/workflow;
  export testing:fibo-workflow-obelisk-schedule/workflow;
}
package obelisk:types@4.1.0 {
  @since(version = 3.0.0)
  interface time {
    @since(version = 3.0.0)
    variant duration {
      milliseconds(u64),
      seconds(u64),
      minutes(u32),
      hours(u32),
      days(u32),
    }

    /// A time and date in seconds plus nanoseconds.
    /// Extracted from wasi:clocks@0.2.0 to avoid dependency on wasi:io
    @since(version = 3.0.0)
    record datetime {
      seconds: u64,
      nanoseconds: u32,
    }

    @since(version = 3.0.0)
    variant schedule-at {
      now,
      at(datetime),
      in(duration),
    }
  }
  @since(version = 4.0.0)
  interface execution {
    use time.{duration};

    @since(version = 3.0.0)
    record execution-id {
      id: string,
    }

    @since(version = 3.0.0)
    record delay-id {
      id: string,
    }

    @since(version = 3.0.0)
    record function {
      /// `namespace:pkg_name/ifc_name` or `namespace:pkg_name/ifc_name@version`
      interface-name: string,
      /// must not contain dot (`.`)
      function-name: string,
    }

    @since(version = 3.0.0)
    variant response-id {
      execution-id(execution-id),
      delay-id(delay-id),
    }

    @since(version = 3.0.0)
    record function-mismatch {
      /// Workflow requested function
      specified-function: function,
      /// What was found actually during execution. None if delay was found as next unprocessed response.
      actual-function: option<function>,
      actual-id: response-id,
    }

    /// Error that is thrown by `-await-next` extension functions.
    @since(version = 3.0.0)
    variant await-next-extension-error {
      /// All submitted requests and their responses of specified function and join set were already processed.
      all-processed,
      /// Execution response was awaited and marked as processed, but it belongs to a different function.
      /// This can happen when join set contains responses of multiple functions or delay requests.
      function-mismatch(function-mismatch),
    }

    /// Error variants that may occur when calling `-get` extension functions.
    @since(version = 3.0.0)
    variant get-extension-error {
      /// Execution is found in processed responses, but it belongs to a different function.
      /// This can happen when join set contains responses of multiple functions.
      function-mismatch(function-mismatch),
      /// Processed responses do not contain the specified execution ID.
      /// Execution was not awaited using `-await-next` extension or `join-set.join-next`.
      not-found-in-processed-responses,
    }

    /// Error variants that may occur when calling `-invoke` extension functions.
    @since(version = 3.0.0)
    variant invoke-extension-error {
      invalid-name(string),
    }

    /// Error variants that may occur when calling `-stub` extension functions.
    @since(version = 3.0.0)
    variant stub-error {
      /// Conflict can happen when a second writer attempts to stub a value, while the
      /// value is not equal to the already stubbed value.
      conflict,
    }

    @since(version = 4.1.0)
    record submit-config {
      /// Override max duration of a execution run (single attempt).
      /// Applies to activities only as workflows automatically extend their locks using `lock_extension` setting.
      timeout: option<duration>,
    }
  }
  @since(version = 4.0.0)
  interface join-set {
    use time.{schedule-at};
    use execution.{delay-id, response-id};

    /// Join set resouce.
    @since(version = 4.0.0)
    resource join-set {
      /// Get the join set identifier in the form of:
      /// * `o:NAME` in case of a one-off join set, where `NAME` is generally an auto-incremented index optionally followed by underscode and a supplied name,
      /// * `g:NAME` in case of a generated join set where `NAME` is generally an auto-incremented index,
      /// * `n:NAME` in case of a named join set
      @since(version = 4.0.0)
      id: func() -> string;
      /// Submit a delay request to the join set. The delay can be later polled using `join-next`.
      /// This function has been moved to `workflow-support`.
      @since(version = 4.0.0)
      @deprecated(version = 4.1.0)
      submit-delay: func(timeout: schedule-at) -> delay-id;
      /// Block the workflow execution until next response associated with the join set arrives.
      /// The response is marked as processed.
      /// Child execution result can be obtained using `-get` extension function using the
      /// returned execution ID.
      /// Return `join-next-error::all-processed` if the join set has all requests matched with responses.
      /// This function has been moved to `workflow-support`.
      @since(version = 4.0.0)
      @deprecated(version = 4.1.0)
      join-next: func() -> result<tuple<response-id, result>, join-next-error>;
    }

    /// Error variants that may occur when calling `join-next` function.
    @since(version = 4.0.0)
    variant join-next-error {
      /// All submitted requests and their responses were already processed.
      all-processed,
    }
  }
}


package obelisk:workflow@4.1.0 {
  interface workflow-support {
    use obelisk:types/join-set@4.1.0.{join-set};
    use obelisk:types/execution@4.1.0.{function, submit-config, execution-id, response-id};
    use obelisk:types/join-set@4.1.0.{join-next-error};

    variant submit-json-error {
      ffqn-parsing-error(string),
      function-not-found,
      params-parsing-error(string),
    }

    variant get-result-json-error {
      execution-id-parsing-error(string),
      not-found-in-processed-responses,
    }

    join-set-create: func() -> join-set;

    submit-json: func(join-set: borrow<join-set>, function: function, params: string, config: option<submit-config>) -> result<execution-id, submit-json-error>;

    get-result-json: func(execution-id: execution-id) -> result<result<option<string>, option<string>>, get-result-json-error>;

    join-next: func(join-set: borrow<join-set>) -> result<tuple<response-id, result>, join-next-error>;
  }
}


package testing:fibo {
  interface fibo {
    fibo: func(n: u8) -> result<u64>;
  }
}


package testing:fibo-obelisk-ext {
  interface fibo {
    use obelisk:types/join-set@4.1.0.{join-set};
    use obelisk:types/execution@4.1.0.{execution-id, await-next-extension-error};

    fibo-submit: func(join-set: borrow<join-set>, n: u8) -> execution-id;

    fibo-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result<u64>>, await-next-extension-error>;
  }
}


package testing:fibo-workflow {
  interface workflow {
    fibow: func(n: u8, iterations: u32) -> result<u64>;

    fiboa: func(n: u8, iterations: u32) -> result<u64>;

    fiboa-concurrent: func(n: u8, iterations: u32) -> result<u64>;

    fiboa-submit-json: func(n: u8) -> result<u64>;

    test-submit-json-unknown-ffqn: func() -> result<_, string>;

    test-submit-json-malformed-params: func() -> result<_, string>;

    test-get-result-json-before-await: func() -> result<_, string>;

    test-get-result-json-err-variant: func() -> result<_, string>;
  }
}


package testing:fibo-workflow-obelisk-ext {
  interface workflow {
    use obelisk:types/execution@4.1.0.{execution-id};
    use obelisk:types/join-set@4.1.0.{join-set};
    use obelisk:types/execution@4.1.0.{await-next-extension-error, get-extension-error};

    fibow-submit: func(join-set: borrow<join-set>, n: u8, iterations: u32) -> execution-id;

    fibow-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result<u64>>, await-next-extension-error>;

    fibow-get: func(execution-id: execution-id) -> result<result<u64>, get-extension-error>;

    fiboa-submit: func(join-set: borrow<join-set>, n: u8, iterations: u32) -> execution-id;

    fiboa-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result<u64>>, await-next-extension-error>;

    fiboa-get: func(execution-id: execution-id) -> result<result<u64>, get-extension-error>;

    fiboa-concurrent-submit: func(join-set: borrow<join-set>, n: u8, iterations: u32) -> execution-id;

    fiboa-concurrent-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result<u64>>, await-next-extension-error>;

    fiboa-concurrent-get: func(execution-id: execution-id) -> result<result<u64>, get-extension-error>;

    fiboa-submit-json-submit: func(join-set: borrow<join-set>, n: u8) -> execution-id;

    fiboa-submit-json-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result<u64>>, await-next-extension-error>;

    fiboa-submit-json-get: func(execution-id: execution-id) -> result<result<u64>, get-extension-error>;

    test-submit-json-unknown-ffqn-submit: func(join-set: borrow<join-set>) -> execution-id;

    test-submit-json-unknown-ffqn-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result<_, string>>, await-next-extension-error>;

    test-submit-json-unknown-ffqn-get: func(execution-id: execution-id) -> result<result<_, string>, get-extension-error>;

    test-submit-json-malformed-params-submit: func(join-set: borrow<join-set>) -> execution-id;

    test-submit-json-malformed-params-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result<_, string>>, await-next-extension-error>;

    test-submit-json-malformed-params-get: func(execution-id: execution-id) -> result<result<_, string>, get-extension-error>;

    test-get-result-json-before-await-submit: func(join-set: borrow<join-set>) -> execution-id;

    test-get-result-json-before-await-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result<_, string>>, await-next-extension-error>;

    test-get-result-json-before-await-get: func(execution-id: execution-id) -> result<result<_, string>, get-extension-error>;

    test-get-result-json-err-variant-submit: func(join-set: borrow<join-set>) -> execution-id;

    test-get-result-json-err-variant-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result<_, string>>, await-next-extension-error>;

    test-get-result-json-err-variant-get: func(execution-id: execution-id) -> result<result<_, string>, get-extension-error>;
  }
}


package testing:fibo-workflow-obelisk-schedule {
  interface workflow {
    use obelisk:types/execution@4.1.0.{execution-id};
    use obelisk:types/time@4.1.0.{schedule-at};

    fibow-schedule: func(schedule-at: schedule-at, n: u8, iterations: u32) -> execution-id;

    fiboa-schedule: func(schedule-at: schedule-at, n: u8, iterations: u32) -> execution-id;

    fiboa-concurrent-schedule: func(schedule-at: schedule-at, n: u8, iterations: u32) -> execution-id;

    fiboa-submit-json-schedule: func(schedule-at: schedule-at, n: u8) -> execution-id;

    test-submit-json-unknown-ffqn-schedule: func(schedule-at: schedule-at) -> execution-id;

    test-submit-json-malformed-params-schedule: func(schedule-at: schedule-at) -> execution-id;

    test-get-result-json-before-await-schedule: func(schedule-at: schedule-at) -> execution-id;

    test-get-result-json-err-variant-schedule: func(schedule-at: schedule-at) -> execution-id;
  }
}
