---
source: crates/utils/src/wit.rs
expression: wit
---
package root:component;

world root {
  import obelisk:types/time@3.0.0;
  import wasi:cli/environment@0.2.3;
  import wasi:cli/exit@0.2.3;
  import wasi:io/error@0.2.3;
  import wasi:io/poll@0.2.3;
  import wasi:io/streams@0.2.3;
  import wasi:cli/stdin@0.2.3;
  import wasi:cli/stdout@0.2.3;
  import wasi:cli/stderr@0.2.3;
  import wasi:clocks/monotonic-clock@0.2.3;
  import wasi:clocks/wall-clock@0.2.3;
  import wasi:filesystem/types@0.2.3;
  import wasi:filesystem/preopens@0.2.3;

  export testing:sleep/sleep;
  export testing:sleep-obelisk-ext/sleep;
  export testing:sleep-obelisk-schedule/sleep;
}
package obelisk:types@3.0.0 {
  @since(version = 3.0.0)
  interface time {
    @since(version = 3.0.0)
    variant duration {
      milliseconds(u64),
      seconds(u64),
      minutes(u32),
      hours(u32),
      days(u32),
    }

    /// A time and date in seconds plus nanoseconds.
    /// Extracted from wasi:clocks@0.2.0 to avoid dependency on wasi:io
    @since(version = 3.0.0)
    record datetime {
      seconds: u64,
      nanoseconds: u32,
    }

    @since(version = 3.0.0)
    variant schedule-at {
      now,
      at(datetime),
      in(duration),
    }
  }
  @since(version = 3.0.0)
  interface execution {
    /// Join set resouce.
    @since(version = 3.0.0)
    resource join-set {
      @since(version = 3.0.0)
      id: func() -> string;
    }

    @since(version = 3.0.0)
    record execution-id {
      id: string,
    }

    @since(version = 3.0.0)
    record delay-id {
      id: string,
    }

    @since(version = 3.0.0)
    record function {
      /// `namespace:pkg_name/ifc_name` or `namespace:pkg_name/ifc_name@version`
      interface-name: string,
      function-name: string,
    }

    @since(version = 3.0.0)
    variant response-id {
      execution-id(execution-id),
      delay-id(delay-id),
    }

    @since(version = 3.0.0)
    record function-mismatch {
      /// Workflow requested function
      specified-function: function,
      /// What was found actually during execution. None if delay was found as next unprocessed response.
      actual-function: option<function>,
      actual-id: response-id,
    }

    /// Error that is thrown by `-await-next` extension functions.
    @since(version = 3.0.0)
    variant await-next-extension-error {
      /// All submitted requests and their responses of specified function and join set were already processed.
      all-processed,
      /// Execution response was awaited and marked as processed, but it belongs to a different function.
      /// This can happen when join set contains responses of multiple functions or delay requests.
      function-mismatch(function-mismatch),
    }

    /// Error variants that may occur when calling `-get` extension functions.
    @since(version = 3.0.0)
    variant get-extension-error {
      /// Execution is found in processed responses, but it belongs to a different function.
      /// This can happen when join set contains responses of multiple functions.
      function-mismatch(function-mismatch),
      /// Processed responses do not contain the specified execution ID.
      /// This can happen if the execution was not marked as processed (awaited), or
      /// the execution ID does not belong to the specified join set.
      not-found-in-processed-responses,
    }

    /// Error variants that may occur when calling `-invoke` extension functions.
    @since(version = 3.0.0)
    variant invoke-extension-error {
      invalid-name(string),
    }

    /// Error variants that may occur when calling `-stub` extension functions.
    @since(version = 3.0.0)
    variant stub-error {
      /// Conflict can happen when a second writer attempts to stub a value, while the
      /// value is not equal to the already stubbed value.
      conflict,
    }
  }
}


package wasi:io@0.2.3 {
  interface error {
    resource error;
  }
  interface poll {
    resource pollable;

    poll: func(in: list<borrow<pollable>>) -> list<u32>;
  }
  interface streams {
    use error.{error};
    use poll.{pollable};

    resource input-stream {
      subscribe: func() -> pollable;
    }

    resource output-stream {
      check-write: func() -> result<u64, stream-error>;
      write: func(contents: list<u8>) -> result<_, stream-error>;
      blocking-write-and-flush: func(contents: list<u8>) -> result<_, stream-error>;
      blocking-flush: func() -> result<_, stream-error>;
      subscribe: func() -> pollable;
    }

    variant stream-error {
      last-operation-failed(error),
      closed,
    }
  }
}


package wasi:cli@0.2.3 {
  interface environment {
    get-environment: func() -> list<tuple<string, string>>;
  }
  interface exit {
    exit: func(status: result);
  }
  interface stdin {
    use wasi:io/streams@0.2.3.{input-stream};

    get-stdin: func() -> input-stream;
  }
  interface stdout {
    use wasi:io/streams@0.2.3.{output-stream};

    get-stdout: func() -> output-stream;
  }
  interface stderr {
    use wasi:io/streams@0.2.3.{output-stream};

    get-stderr: func() -> output-stream;
  }
}


package wasi:clocks@0.2.3 {
  interface monotonic-clock {
    use wasi:io/poll@0.2.3.{pollable};

    type duration = u64;

    type instant = u64;

    subscribe-instant: func(when: instant) -> pollable;

    subscribe-duration: func(when: duration) -> pollable;
  }
  interface wall-clock {
    record datetime {
      seconds: u64,
      nanoseconds: u32,
    }

    now: func() -> datetime;
  }
}


package wasi:filesystem@0.2.3 {
  interface types {
    use wasi:io/streams@0.2.3.{error, input-stream, output-stream};
    use wasi:clocks/wall-clock@0.2.3.{datetime};

    resource descriptor {
      read-via-stream: func(offset: filesize) -> result<input-stream, error-code>;
      write-via-stream: func(offset: filesize) -> result<output-stream, error-code>;
      append-via-stream: func() -> result<output-stream, error-code>;
      get-type: func() -> result<descriptor-type, error-code>;
      stat: func() -> result<descriptor-stat, error-code>;
    }

    enum error-code {
      access,
      would-block,
      already,
      bad-descriptor,
      busy,
      deadlock,
      quota,
      exist,
      file-too-large,
      illegal-byte-sequence,
      in-progress,
      interrupted,
      invalid,
      io,
      is-directory,
      loop,
      too-many-links,
      message-size,
      name-too-long,
      no-device,
      no-entry,
      no-lock,
      insufficient-memory,
      insufficient-space,
      not-directory,
      not-empty,
      not-recoverable,
      unsupported,
      no-tty,
      no-such-device,
      overflow,
      not-permitted,
      pipe,
      read-only,
      invalid-seek,
      text-file-busy,
      cross-device,
    }

    type filesize = u64;

    enum descriptor-type {
      unknown,
      block-device,
      character-device,
      directory,
      fifo,
      symbolic-link,
      regular-file,
      socket,
    }

    type link-count = u64;

    record descriptor-stat {
      %type: descriptor-type,
      link-count: link-count,
      size: filesize,
      data-access-timestamp: option<datetime>,
      data-modification-timestamp: option<datetime>,
      status-change-timestamp: option<datetime>,
    }

    filesystem-error-code: func(err: borrow<error>) -> option<error-code>;
  }
  interface preopens {
    use types.{descriptor};

    get-directories: func() -> list<tuple<descriptor, string>>;
  }
}


package testing:sleep {
  interface sleep {
    use obelisk:types/time@3.0.0.{duration};

    sleep: func(duration: duration) -> result;

    sleep-loop: func(duration: duration, iterations: u32) -> result;

    noop: func() -> result;
  }
}


package testing:sleep-obelisk-ext {
  interface sleep {
    use obelisk:types/time@3.0.0.{duration};
    use obelisk:types/execution@3.0.0.{execution-id, join-set, await-next-extension-error, get-extension-error, invoke-extension-error};

    sleep-submit: func(join-set: borrow<join-set>, duration: duration) -> execution-id;

    sleep-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result>, await-next-extension-error>;

    sleep-get: func(execution-id: execution-id) -> result<result, get-extension-error>;

    sleep-invoke: func(label: string, duration: duration) -> result<result, invoke-extension-error>;

    sleep-loop-submit: func(join-set: borrow<join-set>, duration: duration, iterations: u32) -> execution-id;

    sleep-loop-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result>, await-next-extension-error>;

    sleep-loop-get: func(execution-id: execution-id) -> result<result, get-extension-error>;

    sleep-loop-invoke: func(label: string, duration: duration, iterations: u32) -> result<result, invoke-extension-error>;

    noop-submit: func(join-set: borrow<join-set>) -> execution-id;

    noop-await-next: func(join-set: borrow<join-set>) -> result<tuple<execution-id, result>, await-next-extension-error>;

    noop-get: func(execution-id: execution-id) -> result<result, get-extension-error>;

    noop-invoke: func(label: string) -> result<result, invoke-extension-error>;
  }
}


package testing:sleep-obelisk-schedule {
  interface sleep {
    use obelisk:types/time@3.0.0.{duration};
    use obelisk:types/execution@3.0.0.{execution-id};
    use obelisk:types/time@3.0.0.{schedule-at};

    sleep-schedule: func(schedule-at: schedule-at, duration: duration) -> execution-id;

    sleep-loop-schedule: func(schedule-at: schedule-at, duration: duration, iterations: u32) -> execution-id;

    noop-schedule: func(schedule-at: schedule-at) -> execution-id;
  }
}
