use crate::{args::shadow::PKG_VERSION, config::toml::ConfigToml};
use anyhow::Context;
use concepts::ComponentType;
use schemars::schema_for;
use std::{
    borrow::Cow,
    fs::File,
    io::{BufWriter, Write as _, stdout},
    path::PathBuf,
};
use utils::{wasm_tools::WasmComponent, wit};

pub(crate) fn generate_toml_schema(output: Option<PathBuf>) -> Result<(), anyhow::Error> {
    let schema = schema_for!(ConfigToml);
    if let Some(output) = output {
        // Save to a file
        let mut writer = BufWriter::new(File::create(&output)?);
        serde_json::to_writer_pretty(&mut writer, &schema)?;
        writer.write_all(b"\n")?;
        writer.flush()?; // Do not swallow errors
    } else {
        serde_json::to_writer_pretty(stdout().lock(), &schema)?;
    }
    Ok(())
}

pub(crate) async fn generate_exported_extension_wits(
    input_wit_directory: PathBuf,
    output_directory: PathBuf,
    component_type: ComponentType,
) -> Result<(), anyhow::Error> {
    const HEADER: &str = "// Generated by Obelisk";
    let wasm_component = WasmComponent::new_from_wit_folder(&input_wit_directory, component_type)?;
    let pkgs_to_wits = wasm_component.exported_extension_wits()?;
    for (pkg_fqn, wit) in pkgs_to_wits {
        let pkg_folder = output_directory.join(pkg_fqn.to_string().replace(':', "_"));
        let wit_file = pkg_folder.join(format!("{}.wit", pkg_fqn.package_name));
        let wit = match wit.strip_prefix(HEADER) {
            Some(wit) => {
                if let Some((_, wit)) = wit.split_once('\n') {
                    Cow::Borrowed(wit)
                } else {
                    Cow::Borrowed(wit)
                }
            }
            None => Cow::Owned(wit),
        };
        let wit = match wit.strip_prefix(&format!("/{HEADER}")) {
            // Bug in wasm_tools is turning // into ///
            Some(wit) => {
                if let Some((_, wit)) = wit.split_once('\n') {
                    Cow::Borrowed(wit)
                } else {
                    Cow::Borrowed(wit)
                }
            }
            None => wit,
        };
        let wit = format!("{HEADER} {PKG_VERSION}\n{wit}");
        if let Ok(actual) = tokio::fs::read_to_string(&wit_file).await
            && actual == wit
        {
            println!("{wit_file:?} is up to date");
        } else {
            tokio::fs::create_dir_all(&pkg_folder)
                .await
                .with_context(|| format!("cannot write {pkg_folder:?}"))?;
            tokio::fs::write(&wit_file, wit.as_bytes())
                .await
                .with_context(|| format!("cannot write {wit_file:?}"))?;
            println!("{wit_file:?} created or updated");
        }
    }
    Ok(())
}

pub(crate) async fn generate_support_wits(
    component_type: ComponentType,
    output_directory: PathBuf,
) -> Result<(), anyhow::Error> {
    let files = match component_type {
        ComponentType::ActivityWasm => {
            vec![
                wit::WIT_OBELISK_ACTIVITY_PACKAGE_PROCESS,
                wit::WIT_OBELISK_LOG_PACKAGE,
            ]
        }
        ComponentType::ActivityStub => vec![],
        ComponentType::Workflow => vec![
            wit::WIT_OBELISK_TYPES_PACKAGE,
            wit::WIT_OBELISK_WORKFLOW_PACKAGE,
            wit::WIT_OBELISK_LOG_PACKAGE,
        ],
        ComponentType::WebhookEndpoint => {
            vec![
                wit::WIT_OBELISK_TYPES_PACKAGE, // Needed for -schedule ext functions.
                wit::WIT_OBELISK_LOG_PACKAGE,
            ]
        }
    };
    for [folder, filename, content] in files {
        let output_directory = output_directory.join(folder);
        let path = output_directory.join(filename);
        if let Ok(actual) = tokio::fs::read_to_string(&path).await
            && actual == content
        {
            println!("{path:?} is up to date");
        } else {
            tokio::fs::create_dir_all(&output_directory)
                .await
                .with_context(|| format!("cannot write {output_directory:?}"))?;
            tokio::fs::write(&path, content)
                .await
                .with_context(|| format!("cannot write {path:?}"))?;
            println!("{path:?} created or updated");
        }
    }
    Ok(())
}
